/*globals describe, it, expect, runs, jasmine, beforeEach, afterEach, Routines */

describe('timeout', function() {

    it('returns a new Chan', function() {
        var ret = Routines.timeout();
        expect(ret instanceof Routines.Chan).toEqual(true);
    });

    it('waits the specified miliseconds and then puts that value into the returned Chan', function(done) {
        var expected = 10,
            chan = Routines.timeout(expected),
            actual;

        Routines.go(function* () {
            actual = yield chan.get();
        });

        setTimeout(function() {
          if (actual !== undefined) {
            expect(actual).toEqual(expected);
            done();
          }
        }, 33);

    });

    it('closes the Chan after the time has elapsed', function(done) {
        var chan = Routines.timeout(16),
            expected = [true, false],
            actual = [];

        actual.push(chan.isOpen);

        setTimeout(function() {
          if (!chan.isOpen) {
            actual.push(chan.isOpen);
            expect(actual).toEqual(expected);
            done();
          }
        }, 50);

    });

});


describe('listen', function() {

    var chan, event;

    beforeEach(function() {
        chan = Routines.listen(document, 'click');
        event = document.createEvent('MouseEvents');
        event.initMouseEvent('click', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
    });

    afterEach(function() {
        chan.close();
    });

    it('returns a new EventChan', function() {
        expect(chan instanceof Routines.EventChan).toEqual(true);
    });

    it('sends the event data to the EventChan when the event occurs', function(done) {
        var expected = document,
            actual = [];

        event.initMouseEvent('click', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
        document.dispatchEvent(event);

        Routines.go(function* () {
            actual.push(yield chan.get());
        });

        setTimeout(function() {
          if (actual.length > 0) {
            expect(actual[0].srcElement).toEqual(expected);
            done();
          }
        }, 33);

    });

    it('can call preventDefault when the event is handled', function(done) {
        var eventDataFromChan;

        chan = Routines.listen(document, 'click', true);

        Routines.go(function* () {
            eventDataFromChan = yield chan.get();
        });

        document.dispatchEvent(event);

        setTimeout(function() {
          if (eventDataFromChan !== undefined) {
            expect(eventDataFromChan.defaultPrevented).toEqual(true);
            done();
          }

        }, 33);

    });

});



describe('lazyseq', function() {

    var chan;

    function producer(i) {
        return 'msg ' + i;
    }

    beforeEach(function() {
        chan = Routines.lazyseq(3, producer);
    });

    it('returns a new Chan', function() {
        expect(chan instanceof Routines.Chan).toEqual(true);
    });

    it('puts "count" number of items, each generated by the "fn" argument, into the channel and then closes the channel', function(done) {
        var expected = [{data: 'msg 0'}, {data: 'msg 1'}, {data: 'msg 2'}],
            actual = [];

        Routines.go(function* () {
            var data;
            while (!(data = yield chan.get()).close) {
                actual.push(data);
            }
        });

        setTimeout(function() {
          if (chan.isOpen === false) {
            expect(actual).toEqual(expected);
            done();
          }
        }, 33);

    });

});

describe('denode', function() {

    var chan;

    function nodeStyleFunction(arg0, callback) {
        callback(null, arg0);
    }

    it('produces a channel that gets data when the supplied function invokes its callback', function(done) {
        var expected = ['a'],
            actual = [];

        chan = Routines.denode(nodeStyleFunction, ['a']);

        Routines.go(function* () {
            var el;
            while (!(el = yield chan.get()).close) {
                actual.push(el.data);
            }
        });

        setTimeout(function() {
          if (!chan.isOpen) {
            expect(actual).toEqual(expected);
            done();
          }

        }, 33);

    });
});
